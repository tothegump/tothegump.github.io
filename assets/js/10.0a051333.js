(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{292:function(e,t,a){"use strict";a.r(t);var r=a(4),n=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_2019-04-07"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-04-07","aria-hidden":"true"}},[e._v("#")]),e._v(" 2019-04-07")]),e._v(" "),a("p",[a("strong",[e._v("# 1.Algorithm")])]),e._v(" "),a("blockquote",[a("p",[e._v("每周至少做一个 leetcode 的算法题")])]),e._v(" "),a("p",[e._v("虽然标记难度为中，实际上。。。比前面的都简单")]),e._v(" "),a("p",[e._v("https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Solution:\n    def queryString(self, s: str, n: int) -> bool:\n        s_list = [bin(i)[2:] for i in range(1, n+1)]\n        return all(_ in s for _ in s_list)\n")])])]),a("p",[a("strong",[e._v("# 2.Review")])]),e._v(" "),a("blockquote",[a("p",[e._v("阅读并点评至少一篇英文技术文章\nKombu 的文档比较简单，读完了\n"),a("a",{attrs:{href:"http://kombu.readthedocs.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kombu 的文档"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("另外还有一篇 PEP-205 ，正在阅读中。")]),e._v(" "),a("p",[a("strong",[e._v("# 3.Tip")])]),e._v(" "),a("blockquote",[a("p",[e._v("学习至少一个技术技巧")])]),e._v(" "),a("ul",[a("li",[e._v("使用了 ansible 非常好用")]),e._v(" "),a("li",[e._v("Linux 系统优化（上下文切换）")])]),e._v(" "),a("p",[a("strong",[e._v("# 4.Share")])]),e._v(" "),a("blockquote",[a("p",[e._v("分享一篇有观点和思考的技术文章"),a("br"),e._v("\n本周输出 （没有整理，我还是直接贴在这里吧）：")])]),e._v(" "),a("h1",{attrs:{id:"python-连接-amqp-mq-的客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python-连接-amqp-mq-的客户端","aria-hidden":"true"}},[e._v("#")]),e._v(" Python 连接 AMQP MQ 的客户端")]),e._v(" "),a("h2",{attrs:{id:"可选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可选项","aria-hidden":"true"}},[e._v("#")]),e._v(" 可选项")]),e._v(" "),a("p",[e._v("在 RabbitMQ 的官网中，推荐了 pika 作为 Python 的客户端。毕竟是官网推荐的，当然可以使用，正常使用场景，分为三种：")]),e._v(" "),a("ol",[a("li",[e._v("只是想写一个 "),a("code",[e._v("hello world")]),e._v(" 的简单 demo")]),e._v(" "),a("li",[e._v("要快速、安全、稳定地用起来，过滤掉很多不必要的细节")]),e._v(" "),a("li",[e._v("财大气粗，先把这个 pika 封装好，设计好 api, 供上层调用")]),e._v(" "),a("li",[e._v("超级富豪，自己从零写一个客户端")])]),e._v(" "),a("p",[e._v("对于 1，用什么都无所谓，反正都是玩玩。\n对于 2，用 pika 显然是不行的，过于底层了，缺少必要的封装和工具。\n对于 3，有钱任性。\n对于 4，献上膝盖。\n那么我们先看看 3，有哪些底层框架可供选择吧。")]),e._v(" "),a("h2",{attrs:{id:"比较底层的-amqp-客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比较底层的-amqp-客户端","aria-hidden":"true"}},[e._v("#")]),e._v(" 比较底层的 AMQP 客户端")]),e._v(" "),a("p",[e._v("RabbitMQ 网站上列出了几个，其实看了一圈，也就 pika 和 Celery 比较靠谱了。不过这里 Celery 并不是一个专门的客户端，他所依赖的 Kombu 和 librabbitmq 才是。其中，librabbitmq 是跟 pika 对等的关系。\n其实 librabbitmq 是 C 写的 RabbitMQ 客户端，用 Python 包装了一下。\n所以，如果要选择底层的客户端，那么这两个都可以考虑。其他的，可以看看他们的 Github 主页，看看能否满足自己的要求。")]),e._v(" "),a("h2",{attrs:{id:"封装一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装一下","aria-hidden":"true"}},[e._v("#")]),e._v(" 封装一下")]),e._v(" "),a("p",[e._v("Kombu 就是基于 librabbitmq 所做的封装。除了很多工具外，主要封装出了这么几个类：")]),e._v(" "),a("ul",[a("li",[e._v("Connection (Channel, Transport)")]),e._v(" "),a("li",[e._v("Producer, Consumer")]),e._v(" "),a("li",[e._v("Serialization\n基本上满足了快速使用的基本需求。而且 Kombu 作为上层封装，amqp 只是其中的一个 transport, 可以被替换成 redis, in-memory 等，具体可以看看 [Transport Comparison]")])]),e._v(" "),a("h2",{attrs:{id:"kombu-快速开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kombu-快速开始","aria-hidden":"true"}},[e._v("#")]),e._v(" Kombu 快速开始")]),e._v(" "),a("p",[e._v("最快的开始，当然是什么都不依赖啦，一下子体验 producer 和 consumer 。当然由于过于简陋，可能什么都感受不到(⊙﹏⊙)b\nfrom kombu import Connection")]),e._v(" "),a("h1",{attrs:{id:"往队列里面塞消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#往队列里面塞消息","aria-hidden":"true"}},[e._v("#")]),e._v(" 往队列里面塞消息")]),e._v(" "),a("p",[e._v("with Connection('memory:///') as conn:\nwith conn.SimpleQueue('nothing') as queue:\nqueue.put({'hello': 'world'})")]),e._v(" "),a("h1",{attrs:{id:"从队列里面取消息，打印一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从队列里面取消息，打印一下","aria-hidden":"true"}},[e._v("#")]),e._v(" 从队列里面取消息，打印一下")]),e._v(" "),a("p",[e._v("with Connection('memory:///') as conn:\nwith conn.SimpleQueue('nothing') as queue:\nmessage = queue.get(block=True, timeout=10)\nmessage.ack()\nprint(message.payload)\n直接用内存作为 transport, 上面往队列里面生产一点消息，下面从队列里面消费消息。")]),e._v(" "),a("h2",{attrs:{id:"生产者，消费者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生产者，消费者","aria-hidden":"true"}},[e._v("#")]),e._v(" 生产者，消费者")]),e._v(" "),a("p",[e._v("上面的示例，有点过于简单了，让人感到一脸懵逼，作为严肃的程序员，我们还是想要一套完整的演示的：\n首先，有一个生产者，产生消息\n其次，有一个消费者，消费消息\n另外，每次使用完都要记得关闭，所以直接使用 "),a("code",[e._v("with")]),e._v(" 上下文即可。在 kombu 中提供了示例代码，可以快速的依次看完:")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("hello_publisher.py")]),e._v(" and "),a("code",[e._v("hello_consumer.py")])]),e._v(" "),a("li",[a("code",[e._v("simple_send.py")]),e._v(" and "),a("code",[e._v("simple_receive.py")])]),e._v(" "),a("li",[a("code",[e._v("complete_send.py")]),e._v(" and "),a("code",[e._v("complete_receive.py")]),e._v("\n就可以开始写代码了，当然，前面的 1, 2 都是供理解用的，可以直接按照 3 中的来。")])])])},[],!1,null,null,null);t.default=n.exports}}]);