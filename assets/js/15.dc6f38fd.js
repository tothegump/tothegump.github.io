(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{283:function(a,t,e){"use strict";e.r(t);var v=e(4),n=Object(v.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"java-class-loader-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-class-loader-1","aria-hidden":"true"}},[a._v("#")]),a._v(" Java Class Loader 1")]),a._v(" "),e("p",[a._v("不知道为什么，刚开始学习 Java, 就跟一个叫做“类加载器”的概念杠上了（尴尬）。查了一些资料，总体感觉是，关于这个概念讲起来是比较简单，而且这些资料基本上都在周志明那本书的范围内。看起来很简单，看起来很容易掌握，然鹅，了解了这些概念之后，我却更加迷茫了，感觉自己都明白了，又感觉自己什么都不懂。“听过很多道理，依然过不好这一生”的感觉。")]),a._v(" "),e("h2",{attrs:{id:"乱翻了一些资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乱翻了一些资料","aria-hidden":"true"}},[a._v("#")]),a._v(" 乱翻了一些资料")]),a._v(" "),e("p",[a._v("浏览了很多资料，感觉都是泛泛而谈，说来说去都是")]),a._v(" "),e("ul",[e("li",[a._v("类加载器一共分三类，分别是 Bootstrap Class Loader, Extension Class Loader （Java 9 之后改名为 Platform Class Loader）, Application Class Loader")]),a._v(" "),e("li",[a._v("加载时，采用“双亲委派模型” （吐槽一个，明明是 parent delegation model, 非要翻译成这么个名称，真是）\n。。。")])]),a._v(" "),e("h2",{attrs:{id:"反思"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反思","aria-hidden":"true"}},[a._v("#")]),a._v(" 反思")]),a._v(" "),e("p",[a._v("想了一下，这样乱翻太宽泛了，我怎么才算理解了类加载的概念呢？\n我整理了一下自己的思路，设定了目标和研究路径（这里先卖个关子），开始了自己的探索之旅。")]),a._v(" "),e("h2",{attrs:{id:"基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),e("p",[a._v("第一步，基本概念方面\n首先，”类加载“这个词本身，就是一个动作，所以，我决定，还是要从分析这个动作的各个环节出发，来理解这个过程。\n要达到这个目的，我们先假设自己什么概念都不了解（好吧，我承认，这个不是假设，是真的不了解😓）。")]),a._v(" "),e("h2",{attrs:{id:"类的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期","aria-hidden":"true"}},[a._v("#")]),a._v(" 类的生命周期")]),a._v(" "),e("p",[a._v("想想，如果自己来写一个虚拟机，要怎么去管理类的生命周期。\n0. 定义基本元素：既然 Java 语言 “every thing is a object”, 那么我们不妨把类作为一个基本元素来看。")]),a._v(" "),e("ol",[e("li",[a._v("找到这个类（比如说，定位到这个类的文件地址），获取这个类的内容")]),a._v(" "),e("li",[a._v("分析这个类的内容，根据所拥有的属性和方法，分配相对应的资源")]),a._v(" "),e("li",[a._v("初始化")]),a._v(" "),e("li",[a._v("使用")]),a._v(" "),e("li",[a._v("用完了")])]),a._v(" "),e("p",[a._v("JVM 也是这样管理的：\nLoading -> linking -> initialization -> Using -> Unloading")]),a._v(" "),e("p",[a._v("上面步骤中，1看起来好理解，只要有地址加名称，总归是可实现的。第二步看起来就比较复杂了（确实是，后面再分析吧）。")]),a._v(" "),e("p",[a._v("只看第一步，需要做什么。书中说， Loading 阶段需要完成 3 件事：")]),a._v(" "),e("ol",[e("li",[a._v("通过一个类的全限定名来获取此类的二进制字节流")]),a._v(" "),e("li",[a._v("这个字节流所代表的静态存储结构转化为方法区的运行时数据结构")]),a._v(" "),e("li",[a._v("在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各个数据的访问入口")])]),a._v(" "),e("p",[a._v("嗯，只有第一步能看懂😊")]),a._v(" "),e("p",[a._v("查查资料，"),e("RouterLink",{attrs:{to:"/_posts/!https://mobile.developer.com/java/data/understand-jvm-loading-jvm-linking-and-jvm-initialization.html"}},[a._v("这篇资料翻译了一下")]),a._v(" ：\n* \tCreate a binary stream of data from the class file\n* \tParse the binary data according to the internal data structure\n* \tCreate an instance of "),e("em",[a._v("java.lang.Class")])],1),a._v(" "),e("p",[a._v("额，不知道为什么，感觉第三步也看懂了（这一定是幻觉）。\n继续查了一番资料，更大的幻觉产生了，感觉自己看懂了第二步。\n为了说服自己，这不是自我欺骗，我必须尝试解释一番。")]),a._v(" "),e("p",[a._v("to be continued...")])])},[],!1,null,null,null);t.default=n.exports}}]);